<template><div><h3 id="一、java中如何实现锁" tabindex="-1"><a class="header-anchor" href="#一、java中如何实现锁" aria-hidden="true">#</a> 一、java中如何实现锁</h3>
<p>保持某一段代码的原子性，synchronized是如何实现的。通过jol可以进行实验（观察代码在内存中如何执行的，maven坐标: jol-core）</p>
<p>原子性：上锁之后的代码不可被打断（持有同样锁的其他代码，打断指的是同时运行）</p>
<h3 id="二、锁对比" tabindex="-1"><a class="header-anchor" href="#二、锁对比" aria-hidden="true">#</a> 二、锁对比</h3>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>悲观</th>
<th>乐观</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">描述</td>
<td>悲观的认为数据的竞争特别大，直接将数据锁起来</td>
<td>乐观的认为数据竞争小，不加锁</td>
</tr>
<tr>
<td style="text-align:left">场景</td>
<td>并发大，临界区小</td>
<td>并发小，临界区大</td>
</tr>
<tr>
<td style="text-align:left">例子</td>
<td>行锁，表锁, Synchronized等</td>
<td>版本号、CAS</td>
</tr>
<tr>
<td style="text-align:left">缺点</td>
<td>重量级、锁的开销比较大</td>
<td>并发高的乐观锁自旋会导致性能下降</td>
</tr>
</tbody>
</table>
<ol>
<li>自旋锁：从字面的意思看就是自我旋转，应用到乐观锁中比如带上版本号修改数据的时候，如果版本被其他线程修改了则重新获取新的版本号后再次修改，一直自旋到成功为止。</li>
<li>乐观锁：乐观的认为数据被修改的情况少，然后不加锁。在不加锁的情况下如果偶尔遇到了其他线程就可以用版本号+自旋锁去解决</li>
<li>悲观锁：悲观的认为数据被修改的情况多，直接将数据锁起来。并发高的时候必须等之前的线程处理完成之后才操作数据</li>
<li>互斥锁：线程在进入临界区的时候需要先获得锁，退出临界区需要释放锁。如果其他限制在使用锁则进入到阻塞状态直到被释放</li>
</ol>
<h3 id="三、整理锁" tabindex="-1"><a class="header-anchor" href="#三、整理锁" aria-hidden="true">#</a> 三、整理锁</h3>
<table>
<thead>
<tr>
<th>锁名称</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平锁</td>
<td>按照申请锁的顺序获取锁</td>
<td></td>
</tr>
<tr>
<td>非公平锁</td>
<td>获取锁的顺序不固定</td>
<td>ReentrantLock、Synchronized</td>
</tr>
<tr>
<td>可重入锁</td>
<td>在外层方法获取锁后在进入内层方法也自动获取锁</td>
<td>ReentrantLock、Synchronized</td>
</tr>
<tr>
<td>独享锁</td>
<td>只能被一个线程使用</td>
<td>ReentrantLock、Synchronized</td>
</tr>
<tr>
<td>共享锁</td>
<td>可以被多个线程使用</td>
<td>ReadWriteLock(读是共享锁,写诗独享锁)</td>
</tr>
<tr>
<td>互斥锁</td>
<td>访问前加锁访问后解锁（多人抢一个马桶）</td>
<td>ReentrantLock</td>
</tr>
<tr>
<td>读写锁</td>
<td>是共享锁也是互斥锁，读的时候共享写的时候互斥</td>
<td>ReadWriteLock</td>
</tr>
<tr>
<td>分段锁</td>
<td>锁的设计，为了细化锁粒度。</td>
<td>ConcurrentHashMap</td>
</tr>
<tr>
<td>偏向锁</td>
<td>代码一直被一个线程使用则线程会自动获取锁</td>
<td>Synchronized的前版本</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>当偏向锁被另一个线程访问时则升级为轻量级锁，其他线程通过自旋获取锁</td>
<td></td>
</tr>
<tr>
<td>重量级锁</td>
<td>轻量级锁自旋到一定值时会进入阻塞后膨胀为重量级锁</td>
<td></td>
</tr>
<tr>
<td>自旋锁</td>
<td>线程不会进入阻塞状态，通过循环方式获取锁，减少上下午切换</td>
<td></td>
</tr>
<tr>
<td>乐观锁</td>
<td>乐观的认为数据被修改的情况少，然后不加锁</td>
<td>版本号+自旋锁、CAS</td>
</tr>
<tr>
<td>悲观锁</td>
<td>悲观的认为数据被修改的情况多，直接将数据锁起来</td>
<td>行锁、表锁、Synchronized</td>
</tr>
</tbody>
</table>
<h3 id="四、提高系统性能" tabindex="-1"><a class="header-anchor" href="#四、提高系统性能" aria-hidden="true">#</a> 四、提高系统性能</h3>
<p>提高系统性能(系统性能的大部分问题都在数据库，数据只有一份但是并发操作的情况多。这种情况下在过滤无用请求后就可以考虑如何减少数据锁提高性能)。提高性能大致分为物理优化(机器选型)、配置优化(根据机器的选型进行各种配置调整)、程序优化(减少锁的使用)</p>
<h4 id="_4-1-乞丐版" tabindex="-1"><a class="header-anchor" href="#_4-1-乞丐版" aria-hidden="true">#</a> 4.1 乞丐版</h4>
<ol>
<li>用CDN的内容分发就近获取数据（服务区域化部署，提高用户访问速度）</li>
<li>前端页面的接口限制防止重复点击、页面懒加载（限制无效请求）</li>
<li>利用Nginx进行限流，防止单个ip重复请求，负载均衡（限制无效请求）</li>
<li>用Redis缓存读多写少的数据，减少数据库的访问（限制无效数据库请求）</li>
<li>利用消息队列去削峰填谷，服务去消费的时候就可以用乐观锁队列消费数据（将某一刻的高并发转化为异步队列处理）</li>
<li>数据库添加索引优化，历史数据使用不多可以进行归档，无法归档的数据可以分库分表（提高数据库执行效率）</li>
<li>服务器的选择，计算多的用CPU密集型，redis服务器用内存密集型。（物理优化）</li>
<li>JVM优化、数据库优化等（配置优化）</li>
</ol>
<h4 id="_4-2-升级版" tabindex="-1"><a class="header-anchor" href="#_4-2-升级版" aria-hidden="true">#</a> 4.2 升级版</h4>
<ol>
<li>网管层：
<ol>
<li>吞吐量和负载一定要保证</li>
<li>ngnix调优</li>
<li>负载均衡</li>
<li>动静分离。</li>
</ol>
</li>
<li>服务层：
<ol>
<li>服务层第一保证高质量的代码，算法优化。</li>
<li>服务拆分，一些可能出现超高并发的接口单独抽取出一个服务。</li>
<li>微服务结合容器技术达到弹性扩容。</li>
<li>缓存技术减少数据库的压力。</li>
<li>运用可靠消息+最终一致性的柔性事务方式解耦高并发服务和其他服务。</li>
</ol>
</li>
<li>数据库：
<ol>
<li>按照业务场景选用合适的数据库引擎</li>
<li>sql优化</li>
<li>海量数据是不是需要分表分库设计</li>
<li>数据库之前需不需要设计布隆过滤器等等。</li>
</ol>
</li>
<li>Java单体服务
<ol>
<li>jvm参数调优</li>
<li>选用合适的垃圾收集器</li>
<li>内存合理分配。</li>
</ol>
</li>
</ol>
</div></template>


