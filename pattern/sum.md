---
title: 设计模式－总结
date: 2018-10-29 22:50:11
tags: java
categories: patterm
keywords: 设计模式总结
description: 设计模式就是一套反复使用、多人知晓、分类遍目的代码设计经验的总结。设计模式学完了,我也要总结一下了。
---

> 已经将head first一书看完了，应该总结一下这本书学到了些什么，下面就将自己学习的设计模式整理一下，方便自己后期复习，以及简短的描述各个设计模式的定义，以及在哪些方面需要使用到设计模式。

## 什么是设计模式

设计模式就是很多面向对象的开发者，根据自己开发的经验，想出来的一些模式，经过时间的认证和大多数程序员的认同后形成的一种比较好的开发模式。利用这些模式，程序员之间可以有自己的方言，程序之间沟通也更加便捷。也很利于代码的维护和扩展。是一套反复使用、多人知晓、分类遍目的代码设计经验的总结。

## 模式词汇(23个)

| 创建型        |   5个         |  |||
| :---- | :---- | :----|:----|:----|
| singleton 单例      | builder 生成器（建造者） | prototype  原型|abstract factory 抽象工厂|factory method 工厂方法|

| 行为型|11个 | |||
| :---- | :----| :----|:----|:----|
| template method 模版方法 | command 命令 | observer 观察者|state 状态| mediator 中介|
| iterator  迭代器 | strategy 策略 | interpreter 解释器 |chain of responsibility 责任链|memento 备忘录|
| visitor 访问者 | |  |

| 结构型 |7个||||
| :---- | :---- | :---- |:----|:----|
| proxy 代理 | decorator 装饰 | composite 复合 |facade 外观|adapter 适配器|
| flyweight 享元 | bridge 桥接 |  |

## 模式何时用

### 创建型模式

|模式名称|何时用|备注|
|:--|:--|:--|
|单例 singleton|你需要程序中只用一个共享的对象|确保一个类只有一个实例|
|建造者 builder|需要创建一个复杂对象的时候|由多个简单对象构建为一个复杂对象|
|原型 prototpye|需要创建许多重复且互不干扰的对象时|通过复制对象实现|
|抽象工厂 abstract factory|创建一系列产品族时（多个产品）|提供一个创建一系列相互依赖对象的接口|
|工厂方法 factory method|想动态产生你想要的具体对象（单个产品）|通过简单工厂模式的抽象和推广|

### 行为型模式

|模式名称|何时用|备注|
|:--|:--|:--|
|模版方法 template method|很多类都需要执行固定或者可选的步骤|可以用钩子实现不改变算法结构的时候改变步骤|
|命令 command|多个回退操作，宏纪录|通过把请求或操作封装到类中，支持撤销、恢复操作|
|观察者 observer|想让你的发送者和接收者不用同步阻塞的时候|依赖它的对象都会收到通知并自动更新，就像微信订阅号|
|迭代器 iterator|遍历不同类型集合的一种方式|通过访问迭代器接口实现‘下一个’、和’有下一个方法‘|
|策略 strategy|客服端可以根据自己的需求进行相应的选择|把一系列的算法分别封装到对应的类中，实现相同接口之后可以相互替换|
|解释器模式 interpreter|当需要使用一个简单的语言时|将每一个语法规则表示为一个类|
|访问者 visitor|在封装不是很重要，需要给类添加新的能力时|封装某些结构元素的操作，在不改变数据结构的情况下新增新的操作|
|中介者 mediator|利用中介者改善类与类之间的过多耦合|利用星型结构改善(降低多个对象和类之间的通信复杂性)|
|备忘录|在需要纪录操作备忘时，捕获类的内部状态|将被记录的状态记录在外部，帮助维护类聚|
|责任链 chain of responsibility|一个请求需要多个对象处理，形成链条|让对个对象都可以接受请求，就像请假一样(日志打印、请求等)|
|状态 state|在内部状态改变时，进行不同的行为操作|一个状态一个类，改变状态时，对象看这向修改了类|

### 结构型模式

|模式名称|何时用|备注|
|:--|:--|:--|
|代理 proxy|A调不到C，而A可以通过B来调C|通过类似黄牛的代理角色去处理|
|装饰者 decorator|动态的给类添加职责，有别于继承的另外一种选择|通过动态运行时选择不同的具体装饰类，从而实现不同的行为。常见的就是io流|
|组合模式 composite|树状结构的数据时|处理树状结构时候使用|
|外观模式 facade|接口特别多，比较混乱，需要统一调用时|将各个接口统一在一个类中，调用时只需要调用一次|
|适配器 adapter|将一个对象转化为另一个对象|就想转换插头，适配不同的插座一样|
|享元模式 flyweight|共享之前的元对象，减少实例化次数|在相同的对象特别多的时候，通过map存储对象。每次需要新对象时，就去map里面查找，没有则创建|
|桥接模式 bridge|好几个接口，需要同时使用他们的部分特性|就像多种颜色和多种形状组合一样，两种类别都需要扩展|

## 模式定义与用途

### 创建型模式

#### 单例模式

- 定义：确保一个类只有一个实例，并提供全局访问点

- 用途：当只需要一个实例的时候

#### 建造者模式

- 定义：将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。

- 用途：经常被用来创建组合结构

#### 原型模式

- 定义：通过‘复制’一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们称之为的‘原型’，这个原型是可定制的。

- 用途：在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象的时候，可以考虑使用原型。

#### 抽象工厂模式

- 定义：提供一个创建一系列相关或相互依赖对象的接口。

- 用途：系统中有多个的产品族，而每次只使用一个产品族。用来创建一系列相关或相互依赖对象的接口

#### 工厂方法模式

- 定义：由子类决定要创建的具体类是那一个

- 用途：由工厂生产产品，如果用简单工厂模式生产新的产品，就要更改工厂类，违背了开闭原则。工厂方法模式就是将类更工厂化，让扩展更简单。

### 行为型模式

#### 模版方法

- 定义：在一个方法中定义一个算法的骨架,而将一些步骤延伸到之类中，模版方法使得之类可以在不改变算法结构的情况下，重新定义算法中的某些步骤

- 用途：一个可共用的模版，在共用的方法中子类可以利用钩子重新定义算法步骤。

#### 命令模式

- 定义：将请求封装成对象，这可以让你使用不同的请求、队列或者日志请求来参数化其他对象。命令模式也支持撤销操作

- 用途：将单个的请求封装为对象。

#### 观察者模式

- 定义：让对象在状态改变时被通知

- 用途：观察者模式就是相当于公众号一样，你关注公众号就会受到消息，取消就收不到消息，一对多的关系。

#### 迭代器

- 定义：提供一种方法，顺序访问一个聚合对象中的各个元素，而又不暴露内部的实现。

- 用途：用来遍历集合中有不同对象的一种统一方式。

#### 策略模式

- 定义：封装可以交互的行为，并使用委托来决定要使用那一个

- 用途：策略模式就是通过不同的策略可以给对象组装不同的行为，比如给小猫小狗添加不同的行为等。


#### 解释器模式

- 定义：提供了评估语言的语法或表达式的方式，这种模式实现了一个表达式接口，该接口解释一个特定的上下文。

- 用途: 当需要实现一个简单的语言时，可以使用解释器。

#### 访问者模式

- 定义：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的情况下定义作用于这些元素的新的操作。

- 用途：当你想要为一个对象的组合增加新的能力，且封装并不重要时，可以使用访问者模式。

#### 中介者模式

- 定义：用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示的相互作用，从而时耦合松散，而且可以独立地改变它们之间的交互。

- 用途：使用中介者模式来集中相关对象之间复杂的沟通和控制方式。常常用来协调相关的GUI组件。

#### 备忘录模式

- 定义：在不破坏封装的情况下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。

- 用途：当你需要让对象返回之前的状态，如你的用户请求‘撤销’，就可以使用备忘录模式。常常用来存储状态。

#### 责任链模式

- 定义：使多个对象都有机会处理请求，从而避免了请求的发送者与接收者之间的耦合关系。将这些对象连成一条链，并沿着一条链传递这请求，直到有对象处理它为止。

- 用途：当你想让一个以上的对象能有机会处理某个请求的时候，就可以使用责任链模式。

#### 状态模式

- 定义：允许一个对象在其内部状态发生改变时改变它的行为，对象看起来似乎修改了它的类。又叫状态对象。

- 用途：在工作流和游戏等类型的软件中经常使用，经常处理一批状态。比如请假流程（主管批准、经理批准、总经理批准）

### 结构型模式

#### 代理模式

- 定义：为另一个对象提供一个替身或占位符以访问这个对象。

- 用途：代理常常用来保护目标对象的作用，协调调用者和被调用者，降低了系统的耦合度。

#### 装饰者模式

- 定义：包装一个对象，并提供新的行为 

- 用途：就像装修房子一样，选择不同的厂商，不同的材料装饰房子。java io流就是使用的装饰模式

#### 复合模式

- 定义：结合两个或两个以上的模式，组成一个解决方案，解决一再发生的一般性问题。

- 用途：通过多个模式去解决复杂的问题，实现不同的功能。常见的就是mvc模式 

#### 外观模式

- 定义：提供了一个统一的接口。用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易访问。

- 用途: 封装一个统一的接口，就像很多插头插在一个大擦板上面，每次使用的时候，只需要按大插板的开关。

#### 适配器模式

- 定义：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

- 用途: 就像转换插头一样，转换接口。 


#### 享元模式

- 定义：运用共享技术有效地支持大量细粒度对象的复用，系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次反复使用，由于享元模式对象需要是细粒度对象，所以又叫轻量模式、蝇量模式。

- 用途：如果想让某个实例能提供很多的虚拟实例，就可以使用享元模式，也叫蝇量模式。

#### 桥接模式

- 定义：将抽象部分与它的实现部分分离，使它们可以独立的变化

- 用途：不只改变你的实现，也改变你的抽象，适合使用在跨越多个平台的图形和窗口系统上。





